- SGL_Util::setClientOs

 changes
=========
Request object now stored in request registry ($input)
SGL_HTTP_REQUEST renamed to SGL_Request
$GLOBALS['_SGL']['REQUEST'] discontinued in favour of true singleton

url
===
- moved resolution of $_SERVER['PHP_SELF'] to SGL_URL::resolveServerVars($conf) in constants.php
- SGL_Url now uses a parser strategy and can handle seagull urls as well as traditional
- SGL_Url stored in registry
- explain SGL_Url object
- getSignificantSegments changed to toPartialArray

templates
=========
- template engine now configurable, flexy implemented as driver

request
=======
- request type now content sensitive, HTTP and CLI contexts implemented

TODO
====
 - observer for LoginMgr
 - create an SGL_User object that extends DB_DataObject_Usr
 - create an ExperiencedDevelopers section in the wiki explaining pattern usage in sgl
 - make all conf.ini files conf.ini.dist, create a Config::buildFromDist, and store data in var, ie conf_user.ini/php
 - messaging should use strategy, ie, email, instant msg, sms etc
// $msgSystem = ReceiverFactory::getMessageSystem();
 - create request strategy to handle CLI, etc
 - clean up Sgl_Manager with command objects
 - move makeIniUnreadable to Config when ready
 - build SGL_Delegator for php4/5 compat delegation
 
/*
fake user request
$controller = new SGL_AppController();
$context = $controller->getContext();
$context->addParam('action', 'login');
$context->addParam('username', 'joe');
$context->addParam('password', 'tiddles');
$controller->process();
*/


class SGL_AppController
{
    var $context;
    
    function SGL_AppController()
    {
        $this->context = new SGL_RequestRegistry();   
    }
    
    function getContext()
    {
        return $this->context;   
    }
    
    function getView($req) 
    {
        return $req->getTemplate();
    }
    
    function getForward() {}
    
    function process()
    {
        //p. 248
        while ($cmd = $this->getCommand($this->context->get('action'))) { // pass $req
            $cmd->execute($this->context);
        }
        $this->diplay($this->getView($req));
    }
    
    function getCommand($req)
    {
        $cmd = $req->get('action');
        if (! $cmd) {
            return new DefaultMgr();   
        }
        
        $oCmd = $this->resolveCommand($cmd);
        return $oCmd;
    }  
    
    function resolveCommand()
    {
        
    }
}


class SGL_Command /* abstract */
{
    var $status;
    
    function execute($req)
    {
        $this->status = $this->_doExecute($req);
        $req->set('cmd', $this);
    }
    
    function getStatus()
    {
        return $this->status;   
    }
}